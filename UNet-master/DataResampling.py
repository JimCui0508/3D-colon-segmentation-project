# -*- coding: utf-8 -*-
"""3DUnet_BraTS2019_colab.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1C0-djxJK1kp_qmLYPSC_CP0U69u46BxS
"""

#Code sourced from following links
#https://github.com/sarthak25/Brain-tumor-segmentation
#https://github.com/karolzak/keras-unet/tree/master/keras_unet
#https://github.com/MohamedAliHabib/Brain-Tumor-Detection
#https://github.com/charan223/Brain-Tumor-Segmentation-using-Topological-Loss
#https://github.com/sdsubhajitdas/Brain-Tumor-Segmentation
#https://github.com/Mehrdad-Noori/Brain-Tumor-Segmentation
#https://github.com/yunyuntsai/BraTS-brain-tumer-segmentation/blob/master/Seg_net.ipynb

#import tensorflow as tf
import os
import SimpleITK as sitk
import matplotlib.pyplot as plt
import skimage.io as io
from glob import glob

import numpy as np
import random as r


'''
gpus = tf.config.experimental.list_physical_devices('GPU')
if gpus:
    try:
        # Currently, memory growth needs to be the same across GPUs
        for gpu in gpus:
            tf.config.experimental.set_memory_growth(gpu, True)
 #           tf.config.experimental.set_virtual_device_configuration(
  #      gpus[0],[tf.config.experimental.VirtualDeviceConfiguration(memory_limit=2560)])
        logical_gpus = tf.config.experimental.list_logical_devices('GPU')
        print(len(gpus), "Physical GPUs,", len(logical_gpus), "Logical GPUs")
    except RuntimeError as e:
        # Memory growth must be set before GPUs have been initialized
        print(e)
'''
os.environ["CUDA_VISIBLE_DEVICES"] = "0,1,2,3"

path = "/home/public/CTC_ReconResults/zip_files/"


origin_files = glob(path+"/1.3.6.1.4.1.9328.50.4.*/**/oldY.nii", recursive=True)
seg_files = glob(path+"/1.3.6.1.4.1.9328.50.4.*/**/??.nii", recursive=True)


print(len(origin_files),len(seg_files))




"""# Convert to Array"""

first_img = io.imread(origin_files[1], plugin="simpleitk")

print(f"shape: {first_img.shape}")
print(f"dtype: {first_img.dtype}")

"""## Visualize Flair Image"""

fig = plt.figure(figsize=(20,15))

ax1 = fig.add_subplot(1,3,1)
ax1.imshow(first_img[256,:,:])
plt.title("axial (transverse) plane", fontsize=20)

ax2 = fig.add_subplot(1,3,2)
ax2.imshow(first_img[:,256,:])
plt.title("coronal plane", fontsize=20)

ax3 = fig.add_subplot(1,3,3)
ax3.imshow(first_img[:,:,256])
plt.title("sagittal plane", fontsize=20);



"""## Visualize Segmented Image"""


seg_img = io.imread(seg_files[1], plugin="simpleitk")

print(f"shape: {seg_img.shape}")
print(f"dtype: {seg_img.dtype}")

fig = plt.figure(figsize=(20,15))

ax1 = fig.add_subplot(1,3,1)
ax1.imshow(seg_img[256,:,:])
plt.title("segmentation for axial (transverse) plane", fontsize=15)

ax2 = fig.add_subplot(1,3,2)
ax2.imshow(seg_img[:,256,:])
plt.title("segmentation for coronal plane", fontsize=15)

ax3 = fig.add_subplot(1,3,3)
ax3.imshow(seg_img[:,:,256])
plt.title("segmentation for sagittal plane", fontsize=15);

"""# Convert to Array """
def resize_image_itk(itkimage, newSize, resamplemethod=sitk.sitkLinear):
  #  rescalFilt = sitk.RescaleIntensityImageFilter() # 改变图像的像素值，转换为[0，1]
  #  rescalFilt.SetOutputMaximum(1) # 设置最大值为1，则会把大于1的都变成1
  #  rescalFilt.SetOutputMinimum(0)  # 设置最小值为0，则会把小于0的都变成0
  #  itkimage = rescalFilt.Execute(itkimage)
    resampler = sitk.ResampleImageFilter()
    originSize = itkimage.GetSize()  # 原来的体素块尺寸
    originSpacing = itkimage.GetSpacing()
    newSize = np.array(newSize,float)
    factor = originSize / newSize
    newSpacing = originSpacing * factor
    newSize = newSize.astype(int) #spacing肯定不能是整数
    resampler.SetReferenceImage(itkimage)  # 需要重新采样的目标图像
    resampler.SetSize(newSize.tolist())
    resampler.SetOutputSpacing(newSpacing.tolist())
    resampler.SetTransform(sitk.Transform(3, sitk.sitkIdentity))
    if resamplemethod == sitk.sitkNearestNeighbor:
        resampler.SetOutputPixelType(sitk.sitkUInt8)   # 近邻插值用于mask的，保存uint8
        resampler.SetInterpolator(resamplemethod)
        itkimgResampled = resampler.Execute(itkimage)
      #  sitk.WriteImage(itkimgResampled,"../ResampledImg.nii.gz")
    else:
        resampler.SetOutputPixelType(sitk.sitkFloat32)  # 线性插值用于PET/CT/MRI之类的，保存float32
        resampler.SetInterpolator(resamplemethod)
        itkimgResampled = resampler.Execute(itkimage)  # 得到重新采样后的图像
      #  sitk.WriteImage(itkimgResampled,"../ResampledMask.nii.gz")
    return itkimgResampled

def to_array(path, end, label=False):

    # get locations
    files = glob(path+end, recursive=True)
    reconfiles = glob("/home/public/CTC_ReconResults/zip_files/1.3.6.1.4.1.9328.50.4.*/**")
    img_list = []
    i = 0

    
    for file in files:

        img = sitk.ReadImage(file)
  
        if label:
            #print(reconfiles[i])
            #print(file)
            img = resize_image_itk(img, (128,128,128), resamplemethod=sitk.sitkNearestNeighbor)
            sitk.WriteImage(img,reconfiles[i]+"/ResampledMaskv2.nii.gz")
        else:
            img = resize_image_itk(img, (128,128,128), resamplemethod=sitk.sitkLinear)
            sitk.WriteImage(img,reconfiles[i]+"/ResampledImgv2.nii.gz")
        # standardization
    #    img = (img-img.mean())/img.std()
      #  img.astype("float32")
     #   print("img:",img.shape)
        
        i = i+1
   
    return 0

"""### np.expand_dims()"""

first_img.shape



"""# Applying the Function"""

to_array(path=path, end="/1.3.6.1.4.1.9328.50.4.*/**/oldY.nii")




to_array(path=path, end="/1.3.6.1.4.1.9328.50.4.*/**/??.nii", label=True)






